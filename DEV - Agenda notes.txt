==============================================================
July 30, 2025 - KriSYS project status. The current state includes:

****************************
Note on Admin Alerts vs. User Messages:
    - Admin Alerts: These are sent by the admin (via a station) and are not encrypted. They are meant to be broadcasted to everyone and should be stored in plaintext on the blockchain.
    
    - User Messages: These are sent between users (via their wallets) and are encrypted using PGP. Only the intended recipient should be able to decrypt them.
****************************

1. Blockchain Implementation: A custom blockchain in Python with:
	- Block creation every 3 minutes (configurable per crisis policy)
	- Transaction structure supporting multiple types (check-in, message, alert, damage_report)
	- Wallet system for families and individuals
	- Policy system allowing crisis-specific configurations

2. Crisis Policy: We have created a hurricane crisis policy with:
	- Block interval: 180 seconds
	- Max transaction size: 10 KB
	- Rate limit: 600 seconds between messages per station
	- Priority levels: evacuation (1), medical (2), shelter (3), supplies (4), personal (5)
	- Transaction types: check_in, message, alert, damage_report

3. API Endpoints:
	- Blockchain explorer (GET /blockchain)
	- Address-based transaction lookup (GET /address/<address>)
	- Wallet management (POST /wallet, GET /wallet/<family_id>)
	- Transaction submission (POST /transaction)
	- Authentication endpoints for wallet access
	- Admin endpoints for manual mining and policy changes (admin token protected)
	- Crisis metadata endpoint (GET /crisis)

4. Database: SQLite database with tables for blocks, transactions, wallets, and crises.

5. Frontend: Basic HTML/JS interfaces for blockchain exploration and QR code scanning (to be expanded).

Next Steps:
1. Testing: Write tests to verify the system, especially for the new crisis policy and transaction types.
2. Wallet Messaging: Implement PGP encryption for wallet-to-wallet messages.
3. Admin Alerts: Implement plaintext alert broadcasting by admin (to be readable by all).
4. Check-in Stations: Implement station functionality (check-in, alerts, warnings).
5. Frontend Expansion: Build out the wallet interface and admin panel.



==============================================================

Encrypted Label Storage:
	- Use family's public key to encrypt labels
	- Store encrypted labels in wallets table
	- Decrypt client-side with private key derived from password

IDEA OF WALLET AND ADDRESS MANAGEMENT SYSTEM FEATURES:

The idea is addresses related to a wallet (family/group) should be able to label addresses of that group so that each can be easily associated with members of the group, but we don't want that information to be visible to anyone on the blockchain, only the family themselves. Other people can add individuals to their wallets and label those people themselves and that would be encrypted on that other person's contact list, whether the information they enter is right or wrong is irrelevent, the lable is stored as a transaction type and encrypted allowing only the person/group who entered the label to read it in plain english.

Family/Group wallets should be able to add new members, label them with names, view notifications for all transactions matching family wallet address, and select specific addresses for transactions registered including that individual's address. Group messages display in the individual's dashboard as well as the family dashboard.

Family wallet must be protected by password for backup, but ideally the family devices can register their TPM (Trusted Platform Module) built into their devices to decrypt messages and labels, provide access to the dashboard, and to allow offline/online transactions to get posted from their address and signatures. PGP key pairs with the blockchain provider issuing a public key to all users on the network is ideal to safeguard message data and prevent "LOG4J" brand of attacks via sql injection or other similar security situations requiring input sanitization at the server's API.

Need to consider default method of message verification (fingerprint or signature via PGP?) and the blockchain should have its own key pair, issuing all wallets the public key to ensure public chain does not leak personal details in any of the transactions posted by any of the users when they submit new messages.

AUTH METHODS (defaults, framework overrides are an option, thank FOSS):
1) Primary Authentication: PGP-based challenge-response for strong security
2) Fallback Authentication: Password-based for device recovery
3) Device Registration: For seamless access on trusted devices

WALLET AUTHENTICATION FLOW
sequenceDiagram
    participant Client
    participant Server
    participant Blockchain
    Client->>Server: Request challenge
    Server->>Client: Send nonce
    Client->>Client: Sign nonce with private key
    Client->>Server: Send signed nonce + public key fingerprint
    Server->>Blockchain: Retrieve public key by fingerprint
    Blockchain->>Server: Return public key
    Server->>Server: Verify signature
    Server->>Client: Auth token if valid

SECURITY ARCHITECTURE
graph TD
    A[User] -->|Initiate| B[Wallet Dashboard]
    B --> C{Device Registered?}
    C -->|Yes| D[PGP Challenge-Response]
    C -->|No| E[Password Authentication]
    D --> F[Access Granted]
    E --> F
    F --> G[Manage Wallet]
    G --> H[Add Members]
    G --> I[View Notifications]
    G --> J[Generate Addresses]
    G --> K[Register New Devices]

WALLET MANAGER AND BLOCKCHAIN FLOW
graph TD
    A[app.py] --> B[Blockchain]
    B --> C[WalletManager]
    C --> D[Wallet]
    D --> E[WalletAuth]
    C --> F[Database]
    
    style A fill:#f9f,stroke:#333
    style B fill:#bbf,stroke:#333
    style C fill:#f96,stroke:#333
    style D fill:#6f9,stroke:#333
    style E fill:#9cf,stroke:#333
    style F fill:#cff,stroke:#333


>>> TEST WALLET MANAGER AND PGP DEFAULT AUTH

-create wallet
wallet = blockchain.wallets.create_wallet("fam_123", [{"name": "John Doe"}])

-get wallet
wallet = blockchain.wallets.get_wallet("fam_123")

-add device
blockchain.wallets.add_device_to_wallet("fam_123", "device_456", public_key)


# Example: Load a public key from string
from pgpy import PGPKey

public_key = PGPKey()
public_key.parse(wallet.members[0]["keypair_str"])

<<< TEST WALLET MANAGER AND PGP DEFAULT AUTH

DATABASE AND CRISIS BLOCKCHAIN CREATION - POLICIES (configs/admin setup)





PHASE 2.1 - DEVELOPMENT ROADMAP

Core Dashboard UI (2 days)
	- Complete all page templates
	- Implement navigation and basic styling
	- Mock data integration
 
Authentication System (1 day)
	- Password-based login
	- Device registration flow
	- Session management

Member Management (1 day)
	- Add/remove members
	- Edit labels (with offline support)
	- Generate new addresses
 
Notifications System (1 day)
	- Real-time transaction monitoring
	- Filtering by type and member
	- Individual profile views
 
Offline Capabilities (2 days)
	- Service worker implementation
	- Local data persistence
	- Background sync