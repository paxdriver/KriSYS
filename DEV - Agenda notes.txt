Encrypted Label Storage:
	- Use family's public key to encrypt labels
	- Store encrypted labels in wallets table
	- Decrypt client-side with private key derived from password

IDEA OF WALLET AND ADDRESS MANAGEMENT SYSTEM FEATURES:

The idea is addresses related to a wallet (family/group) should be able to label addresses of that group so that each can be easily associated with members of the group, but we don't want that information to be visible to anyone on the blockchain, only the family themselves. Other people can add individuals to their wallets and label those people themselves and that would be encrypted on that other person's contact list, whether the information they enter is right or wrong is irrelevent, the lable is stored as a transaction type and encrypted allowing only the person/group who entered the label to read it in plain english.

Family/Group wallets should be able to add new members, label them with names, view notifications for all transactions matching family wallet address, and select specific addresses for transactions registered including that individual's address. Group messages display in the individual's dashboard as well as the family dashboard.

Family wallet must be protected by password for backup, but ideally the family devices can register their TPM (Trusted Platform Module) built into their devices to decrypt messages and labels, provide access to the dashboard, and to allow offline/online transactions to get posted from their address and signatures. PGP key pairs with the blockchain provider issuing a public key to all users on the network is ideal to safeguard message data and prevent "LOG4J" brand of attacks via sql injection or other similar security situations requiring input sanitization at the server's API.

Need to consider default method of message verification (fingerprint or signature via PGP?) and the blockchain should have its own key pair, issuing all wallets the public key to ensure public chain does not leak personal details in any of the transactions posted by any of the users when they submit new messages.

AUTH METHODS (defaults, framework overrides are an option, thank FOSS):
1) Primary Authentication: PGP-based challenge-response for strong security
2) Fallback Authentication: Password-based for device recovery
3) Device Registration: For seamless access on trusted devices

WALLET AUTHENTICATION FLOW
sequenceDiagram
    participant Client
    participant Server
    participant Blockchain
    Client->>Server: Request challenge
    Server->>Client: Send nonce
    Client->>Client: Sign nonce with private key
    Client->>Server: Send signed nonce + public key fingerprint
    Server->>Blockchain: Retrieve public key by fingerprint
    Blockchain->>Server: Return public key
    Server->>Server: Verify signature
    Server->>Client: Auth token if valid

SECURITY ARCHITECTURE
graph TD
    A[User] -->|Initiate| B[Wallet Dashboard]
    B --> C{Device Registered?}
    C -->|Yes| D[PGP Challenge-Response]
    C -->|No| E[Password Authentication]
    D --> F[Access Granted]
    E --> F
    F --> G[Manage Wallet]
    G --> H[Add Members]
    G --> I[View Notifications]
    G --> J[Generate Addresses]
    G --> K[Register New Devices]

WALLET MANAGER AND BLOCKCHAIN FLOW
graph TD
    A[app.py] --> B[Blockchain]
    B --> C[WalletManager]
    C --> D[Wallet]
    D --> E[WalletAuth]
    C --> F[Database]
    
    style A fill:#f9f,stroke:#333
    style B fill:#bbf,stroke:#333
    style C fill:#f96,stroke:#333
    style D fill:#6f9,stroke:#333
    style E fill:#9cf,stroke:#333
    style F fill:#cff,stroke:#333


>>> TEST WALLET MANAGER AND PGP DEFAULT AUTH

-create wallet
wallet = blockchain.wallets.create_wallet("fam_123", [{"name": "John Doe"}])

-get wallet
wallet = blockchain.wallets.get_wallet("fam_123")

-add device
blockchain.wallets.add_device_to_wallet("fam_123", "device_456", public_key)


# Example: Load a public key from string
from pgpy import PGPKey

public_key = PGPKey()
public_key.parse(wallet.members[0]["keypair_str"])

<<< TEST WALLET MANAGER AND PGP DEFAULT AUTH

DATABASE AND CRISIS BLOCKCHAIN CREATION - POLICIES (configs/admin setup)





PHASE 2.1 - DEVELOPMENT ROADMAP

Core Dashboard UI (2 days)
	- Complete all page templates
	- Implement navigation and basic styling
	- Mock data integration
 
Authentication System (1 day)
	- Password-based login
	- Device registration flow
	- Session management

Member Management (1 day)
	- Add/remove members
	- Edit labels (with offline support)
	- Generate new addresses
 
Notifications System (1 day)
	- Real-time transaction monitoring
	- Filtering by type and member
	- Individual profile views
 
Offline Capabilities (2 days)
	- Service worker implementation
	- Local data persistence
	- Background sync